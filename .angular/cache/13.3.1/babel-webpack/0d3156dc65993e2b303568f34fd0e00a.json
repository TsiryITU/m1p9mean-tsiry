{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\tsiry\\\\Documents\\\\GitHub\\\\m1p9mean-tsiry\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\classCallCheck.js\";\nimport _createClass from \"C:\\\\Users\\\\tsiry\\\\Documents\\\\GitHub\\\\m1p9mean-tsiry\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createClass.js\";\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport { ɵɵdefineInjectable, ɵɵinject, Injectable, Inject, Optional, EventEmitter, Directive, Input, Output, HostListener, ViewContainerRef, TemplateRef, NgModule } from '@angular/core';\nimport { WINDOW } from 'ngx-window-token';\nimport { Subject } from 'rxjs';\n/**\r\n * The following code is heavily copied from https://github.com/zenorocha/clipboard.js\r\n */\n\nimport * as ɵngcc0 from '@angular/core';\n\nvar ClipboardService = /*#__PURE__*/function () {\n  function ClipboardService(document, window) {\n    _classCallCheck(this, ClipboardService);\n\n    this.document = document;\n    this.window = window;\n    this.copySubject = new Subject();\n    this.copyResponse$ = this.copySubject.asObservable();\n    this.config = {};\n  }\n\n  _createClass(ClipboardService, [{\n    key: \"configure\",\n    value: function configure(config) {\n      this.config = config;\n    }\n  }, {\n    key: \"copy\",\n    value: function copy(content) {\n      if (!this.isSupported || !content) {\n        return this.pushCopyResponse({\n          isSuccess: false,\n          content: content\n        });\n      }\n\n      var copyResult = this.copyFromContent(content);\n\n      if (copyResult) {\n        return this.pushCopyResponse({\n          content: content,\n          isSuccess: copyResult\n        });\n      }\n\n      return this.pushCopyResponse({\n        isSuccess: false,\n        content: content\n      });\n    }\n  }, {\n    key: \"isSupported\",\n    get: function get() {\n      return !!this.document.queryCommandSupported && !!this.document.queryCommandSupported('copy') && !!this.window;\n    }\n  }, {\n    key: \"isTargetValid\",\n    value: function isTargetValid(element) {\n      if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {\n        if (element.hasAttribute('disabled')) {\n          throw new Error('Invalid \"target\" attribute. Please use \"readonly\" instead of \"disabled\" attribute');\n        }\n\n        return true;\n      }\n\n      throw new Error('Target should be input or textarea');\n    }\n    /**\r\n     * Attempts to copy from an input `targetElm`\r\n     */\n\n  }, {\n    key: \"copyFromInputElement\",\n    value: function copyFromInputElement(targetElm) {\n      var isFocus = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      try {\n        this.selectTarget(targetElm);\n        var re = this.copyText();\n        this.clearSelection(isFocus ? targetElm : undefined, this.window);\n        return re && this.isCopySuccessInIE11();\n      } catch (error) {\n        return false;\n      }\n    }\n    /**\r\n     * This is a hack for IE11 to return `true` even if copy fails.\r\n     */\n\n  }, {\n    key: \"isCopySuccessInIE11\",\n    value: function isCopySuccessInIE11() {\n      var clipboardData = this.window['clipboardData'];\n\n      if (clipboardData && clipboardData.getData) {\n        if (!clipboardData.getData('Text')) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n    /**\r\n     * Creates a fake textarea element, sets its value from `text` property,\r\n     * and makes a selection on it.\r\n     */\n\n  }, {\n    key: \"copyFromContent\",\n    value: function copyFromContent(content) {\n      var container = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.document.body;\n\n      // check if the temp textarea still belongs to the current container.\n      // In case we have multiple places using ngx-clipboard, one is in a modal using container but the other one is not.\n      if (this.tempTextArea && !container.contains(this.tempTextArea)) {\n        this.destroy(this.tempTextArea.parentElement || undefined);\n      }\n\n      if (!this.tempTextArea) {\n        this.tempTextArea = this.createTempTextArea(this.document, this.window);\n\n        try {\n          container.appendChild(this.tempTextArea);\n        } catch (error) {\n          throw new Error('Container should be a Dom element');\n        }\n      }\n\n      this.tempTextArea.value = content;\n      var toReturn = this.copyFromInputElement(this.tempTextArea, false);\n\n      if (this.config.cleanUpAfterCopy) {\n        this.destroy(this.tempTextArea.parentElement || undefined);\n      }\n\n      return toReturn;\n    }\n    /**\r\n     * Remove temporary textarea if any exists.\r\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var container = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.document.body;\n\n      if (this.tempTextArea) {\n        container.removeChild(this.tempTextArea); // removeChild doesn't remove the reference from memory\n\n        this.tempTextArea = undefined;\n      }\n    }\n    /**\r\n     * Select the target html input element.\r\n     */\n\n  }, {\n    key: \"selectTarget\",\n    value: function selectTarget(inputElement) {\n      inputElement.select();\n      inputElement.setSelectionRange(0, inputElement.value.length);\n      return inputElement.value.length;\n    }\n  }, {\n    key: \"copyText\",\n    value: function copyText() {\n      return this.document.execCommand('copy');\n    }\n    /**\r\n     * Moves focus away from `target` and back to the trigger, removes current selection.\r\n     */\n\n  }, {\n    key: \"clearSelection\",\n    value: function clearSelection(inputElement, window) {\n      var _a;\n\n      inputElement && inputElement.focus();\n      (_a = window.getSelection()) === null || _a === void 0 ? void 0 : _a.removeAllRanges();\n    }\n    /**\r\n     * Creates a fake textarea for copy command.\r\n     */\n\n  }, {\n    key: \"createTempTextArea\",\n    value: function createTempTextArea(doc, window) {\n      var isRTL = doc.documentElement.getAttribute('dir') === 'rtl';\n      var ta;\n      ta = doc.createElement('textarea'); // Prevent zooming on iOS\n\n      ta.style.fontSize = '12pt'; // Reset box model\n\n      ta.style.border = '0';\n      ta.style.padding = '0';\n      ta.style.margin = '0'; // Move element out of screen horizontally\n\n      ta.style.position = 'absolute';\n      ta.style[isRTL ? 'right' : 'left'] = '-9999px'; // Move element to the same position vertically\n\n      var yPosition = window.pageYOffset || doc.documentElement.scrollTop;\n      ta.style.top = yPosition + 'px';\n      ta.setAttribute('readonly', '');\n      return ta;\n    }\n    /**\r\n     * Pushes copy operation response to copySubject, to provide global access\r\n     * to the response.\r\n     */\n\n  }, {\n    key: \"pushCopyResponse\",\n    value: function pushCopyResponse(response) {\n      this.copySubject.next(response);\n    }\n    /**\r\n     * @deprecated use pushCopyResponse instead.\r\n     */\n\n  }, {\n    key: \"pushCopyReponse\",\n    value: function pushCopyReponse(response) {\n      this.pushCopyResponse(response);\n    }\n  }]);\n\n  return ClipboardService;\n}();\n\nClipboardService.ɵfac = function ClipboardService_Factory(t) {\n  return new (t || ClipboardService)(ɵngcc0.ɵɵinject(DOCUMENT), ɵngcc0.ɵɵinject(WINDOW, 8));\n};\n\nClipboardService.ɵprov = ɵɵdefineInjectable({\n  factory: function ClipboardService_Factory() {\n    return new ClipboardService(ɵɵinject(DOCUMENT), ɵɵinject(WINDOW, 8));\n  },\n  token: ClipboardService,\n  providedIn: \"root\"\n});\n\nClipboardService.ctorParameters = function () {\n  return [{\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [DOCUMENT]\n    }]\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [WINDOW]\n    }]\n  }];\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ClipboardService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [DOCUMENT]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [WINDOW]\n      }]\n    }];\n  }, null);\n})();\n\nvar ClipboardDirective = /*#__PURE__*/function () {\n  function ClipboardDirective(clipboardSrv) {\n    _classCallCheck(this, ClipboardDirective);\n\n    this.clipboardSrv = clipboardSrv;\n    this.cbOnSuccess = new EventEmitter();\n    this.cbOnError = new EventEmitter();\n  } // tslint:disable-next-line:no-empty\n\n\n  _createClass(ClipboardDirective, [{\n    key: \"ngOnInit\",\n    value: function ngOnInit() {}\n  }, {\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      this.clipboardSrv.destroy(this.container);\n    }\n  }, {\n    key: \"onClick\",\n    value: function onClick(event) {\n      if (!this.clipboardSrv.isSupported) {\n        this.handleResult(false, undefined, event);\n      } else if (this.targetElm && this.clipboardSrv.isTargetValid(this.targetElm)) {\n        this.handleResult(this.clipboardSrv.copyFromInputElement(this.targetElm), this.targetElm.value, event);\n      } else if (this.cbContent) {\n        this.handleResult(this.clipboardSrv.copyFromContent(this.cbContent, this.container), this.cbContent, event);\n      }\n    }\n    /**\r\n     * Fires an event based on the copy operation result.\r\n     * @param succeeded\r\n     */\n\n  }, {\n    key: \"handleResult\",\n    value: function handleResult(succeeded, copiedContent, event) {\n      var response = {\n        isSuccess: succeeded,\n        event: event\n      };\n\n      if (succeeded) {\n        response = Object.assign(response, {\n          content: copiedContent,\n          successMessage: this.cbSuccessMsg\n        });\n        this.cbOnSuccess.emit(response);\n      } else {\n        this.cbOnError.emit(response);\n      }\n\n      this.clipboardSrv.pushCopyResponse(response);\n    }\n  }]);\n\n  return ClipboardDirective;\n}();\n\nClipboardDirective.ɵfac = function ClipboardDirective_Factory(t) {\n  return new (t || ClipboardDirective)(ɵngcc0.ɵɵdirectiveInject(ClipboardService));\n};\n\nClipboardDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n  type: ClipboardDirective,\n  selectors: [[\"\", \"ngxClipboard\", \"\"]],\n  hostBindings: function ClipboardDirective_HostBindings(rf, ctx) {\n    if (rf & 1) {\n      ɵngcc0.ɵɵlistener(\"click\", function ClipboardDirective_click_HostBindingHandler($event) {\n        return ctx.onClick($event.target);\n      });\n    }\n  },\n  inputs: {\n    targetElm: [\"ngxClipboard\", \"targetElm\"],\n    container: \"container\",\n    cbContent: \"cbContent\",\n    cbSuccessMsg: \"cbSuccessMsg\"\n  },\n  outputs: {\n    cbOnSuccess: \"cbOnSuccess\",\n    cbOnError: \"cbOnError\"\n  }\n});\n\nClipboardDirective.ctorParameters = function () {\n  return [{\n    type: ClipboardService\n  }];\n};\n\nClipboardDirective.propDecorators = {\n  targetElm: [{\n    type: Input,\n    args: ['ngxClipboard']\n  }],\n  container: [{\n    type: Input\n  }],\n  cbContent: [{\n    type: Input\n  }],\n  cbSuccessMsg: [{\n    type: Input\n  }],\n  cbOnSuccess: [{\n    type: Output\n  }],\n  cbOnError: [{\n    type: Output\n  }],\n  onClick: [{\n    type: HostListener,\n    args: ['click', ['$event.target']]\n  }]\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ClipboardDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[ngxClipboard]'\n    }]\n  }], function () {\n    return [{\n      type: ClipboardService\n    }];\n  }, {\n    cbOnSuccess: [{\n      type: Output\n    }],\n    cbOnError: [{\n      type: Output\n    }],\n    onClick: [{\n      type: HostListener,\n      args: ['click', ['$event.target']]\n    }],\n    targetElm: [{\n      type: Input,\n      args: ['ngxClipboard']\n    }],\n    container: [{\n      type: Input\n    }],\n    cbContent: [{\n      type: Input\n    }],\n    cbSuccessMsg: [{\n      type: Input\n    }]\n  });\n})();\n\nvar ClipboardIfSupportedDirective = /*#__PURE__*/function () {\n  function ClipboardIfSupportedDirective(_clipboardService, _viewContainerRef, _templateRef) {\n    _classCallCheck(this, ClipboardIfSupportedDirective);\n\n    this._clipboardService = _clipboardService;\n    this._viewContainerRef = _viewContainerRef;\n    this._templateRef = _templateRef;\n  }\n\n  _createClass(ClipboardIfSupportedDirective, [{\n    key: \"ngOnInit\",\n    value: function ngOnInit() {\n      if (this._clipboardService.isSupported) {\n        this._viewContainerRef.createEmbeddedView(this._templateRef);\n      }\n    }\n  }]);\n\n  return ClipboardIfSupportedDirective;\n}();\n\nClipboardIfSupportedDirective.ɵfac = function ClipboardIfSupportedDirective_Factory(t) {\n  return new (t || ClipboardIfSupportedDirective)(ɵngcc0.ɵɵdirectiveInject(ClipboardService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef));\n};\n\nClipboardIfSupportedDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n  type: ClipboardIfSupportedDirective,\n  selectors: [[\"\", \"ngxClipboardIfSupported\", \"\"]]\n});\n\nClipboardIfSupportedDirective.ctorParameters = function () {\n  return [{\n    type: ClipboardService\n  }, {\n    type: ViewContainerRef\n  }, {\n    type: TemplateRef\n  }];\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ClipboardIfSupportedDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[ngxClipboardIfSupported]'\n    }]\n  }], function () {\n    return [{\n      type: ClipboardService\n    }, {\n      type: ɵngcc0.ViewContainerRef\n    }, {\n      type: ɵngcc0.TemplateRef\n    }];\n  }, null);\n})();\n\nvar ClipboardModule = /*#__PURE__*/_createClass(function ClipboardModule() {\n  _classCallCheck(this, ClipboardModule);\n});\n\nClipboardModule.ɵfac = function ClipboardModule_Factory(t) {\n  return new (t || ClipboardModule)();\n};\n\nClipboardModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n  type: ClipboardModule\n});\nClipboardModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n  imports: [[CommonModule]]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ClipboardModule, [{\n    type: NgModule,\n    args: [{\n      imports: [CommonModule],\n      declarations: [ClipboardDirective, ClipboardIfSupportedDirective],\n      exports: [ClipboardDirective, ClipboardIfSupportedDirective]\n    }]\n  }], null, null);\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ClipboardModule, {\n    declarations: function declarations() {\n      return [ClipboardDirective, ClipboardIfSupportedDirective];\n    },\n    imports: function imports() {\n      return [CommonModule];\n    },\n    exports: function exports() {\n      return [ClipboardDirective, ClipboardIfSupportedDirective];\n    }\n  });\n})();\n/*\r\n * Public API Surface of ngx-clipboard\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\n\nexport { ClipboardDirective, ClipboardIfSupportedDirective, ClipboardModule, ClipboardService }; //# sourceMappingURL=ngx-clipboard.js.map","map":null,"metadata":{},"sourceType":"module"}